from pprint import pformat, pprint
from itertools import izip_longest
from egg import s, fstan
from egg import all_meanings
##from co import comparison_clauses


LEAF_TYPES = int, str, unicode
is_leaf = lambda n: isinstance(n, LEAF_TYPES)
CONTAINER_TYPES = tuple, set
is_container = lambda n: isinstance(n, CONTAINER_TYPES)


Mark = ()
Void = Mark,


def solve(form, marks):
  '''
  Given a form and a set of names that are Marks assume all other names
  in the form are Void and reduce to basic value (Mark or Void.)
  '''
  for inner in form:
    if is_leaf(inner):
      if inner in marks:
        return Void
    elif solve(inner, marks) == Mark:
      return Void
  return Mark


def cycle(R, P):
  # To calculate the new R first collect all the signals in R that are
  # marks but that are not mentioned in the current P (and so cannot be
  # set to Void by it) then add the marks generated by solving P's
  # expressions with the marks in R.
  return R.difference(P).union(
    signal
    for signal, expression in P.iteritems()
    if not solve(expression, R)
    )


def reify(meaning, form):
  if is_container(form):
    return type(form)(reify(meaning, inner) for inner in form)
  return meaning.get(form, form)


# A little visual aid to see the state of the puzzle.
def _view(r, u):
  return ''.join(
    '.O'[n in r]
    for n in u
    )


def _bits_in(i):
  return (
    bool(i & 2**n)
    for n in reversed(range(len(bin(i)) - 2))
    )


def z(a, b):
  for ga, gb in zip(_bits_in(a), _bits_in(b)):
    r = set()
    if ga: r.add('A')
    if gb: r.add('B')
    yield r





def ifthen(q, a, b):
  return ((a, (q,)), (q, b))


def sorter(A, B, J, K, H, L, reset):
  # The base comparisons..
  jq = ((A,), B)
  kq = ((B,), A)
  # Modified such that the first to trip inhibits the other.
  jq_and_not_K = ((jq,), K)
  kq_and_not_J = ((kq,), J)
  # Then latched into the external signals (to carry over the state from
  # cycle to cycle.)
  JJ = ((J, jq_and_not_K), reset)
  KK = ((K, kq_and_not_J), reset)
  return {
    J: JJ,
    K: KK,
    H: (((KK,), B), (KK, A)),
    L: (((JJ,), B), (JJ, A)),
    }

def I(i, width=3):
  return [
    bool(i & 2**n)
    for n in range(width)
    ]

def l(t):
  n = 0
  while True:
    yield t + str(n)
    n += 1


def claws(tag, n, width=3):
  return tuple(
    (name,) if value else name
    for name, value in zip(l(tag), I(n, width))
    )


def tryit(f):
  for m in all_meanings(f):
    yield set(name for name in m if not m[name])

##a0, a1, a2, b0, b1, b2 = 'a0 a1 a2 b0 b1 b2'.split()
##
##F = ( a2, (b2,), ( (b1,), a1 ), ( (b0,), a0 ) )
##
##print s(F)
##print
##r = range(8)
##for a in r:
##  for b in r:
##    m = set()
##    for bit in range(4):
##      N = 2**bit
##      if a & N: m.add('a' + str(bit))
##      if b & N: m.add('b' + str(bit))
##
##    print '%s > %s = %5s    %5s  %s' % (a, b, a>b, solve(F, m), m)

##for m in tryit((a0, a1, a2, b0, b1, b2)):
##  print solve(F, m), m


def comparator(A_bits, B_bits):
  '''
  Return two expressions that evaluate A > B and A < B.
  '''
  A, B = [], []

  for a, b in zip(A_bits, B_bits):
    ab = ((a,), b)
    ba = ((b,), a)
    A.append(ab)
    B.append(ba)

  return A, B


a, b = comparator(
  'a2 a1 a0'.split(),
  'b2 b1 b0'.split(),
  )


##A, B = comparison_clauses(bits)
##
##A0, A1, A2, B0, B1, B2 = 'a0 a1 a2 b0 b1 b2'.split()
##P = {
##  'H0': (((A,), B0), (A, A0)),
##  'L0': (((B,), B0), (B, A0)),
##  'H1': (((A,), B1), (A, A1)),
##  'L1': (((B,), B1), (B, A1)),
##  'H2': (((A,), B2), (A, A2)),
##  'L2': (((B,), B2), (B, A2)),
##  }


##print s(a)
##print s(b)


##    U = ('A', 'B', 'J', 'K', 'H', 'L', 'reset')
##    S = sorter(*U)
##
##    for k, v in S.items():
##      print k, s(v)
##    print
##
##
##    Z = z(
##      0b1111000001000,
##      0b1111001000000,
##      )
##    #Z = z(1900, 2000)
##    #Z = z(19, 20)
##    #Z = z(23, 18)
##
##    _o = ''.join(name[0] for name in U)
##    print 'AB    %s' % _o[2:]
##
##    D = set() # "Carry" J and K to next cycle.
##    for R in Z:
##      R = R | D
##      D = cycle(R, S)
##      print _view(R, 'AB'), '->', _view(D, U[2:])
##      D = D - {"A", "B"}
##
##    print _view(R, U)
##
