from pprint import pformat, pprint
from itertools import izip_longest
from egg import s, fstan


LEAF_TYPES = int, str, unicode
is_leaf = lambda n: isinstance(n, LEAF_TYPES)
CONTAINER_TYPES = tuple, set
is_container = lambda n: isinstance(n, CONTAINER_TYPES)


Mark = ()
Void = Mark,


def rule30(a, b, c):
  return ((
    ((a,), b,    c  ),
    ( a,  (b,), (c,)),
    ( a,  (b,),  c  ),
    ( a,   b,   (c,)),
    ),)


##def ruleN(n):
##  assert 0 <= n < 256, repr(n)
##  for i, pattern in enumerate(PATTERNS):
##    if n & 2**i:
##      rules.append(pattern
##  def rule(a, b, c):
##    return (
##      ()()() -> __
##      ()()__ -> __
##      ()__() -> __
##      ()____ -> __
##      __()() -> __
##      __()__ -> __
##      ____() -> __
##      ______ -> __
##      )

def pervade(form, remove=None):
  if remove is None:
    remove = set()

  names = set(filter(is_leaf, form))
  names -= remove
  remove = remove | names
  subs = set()

  for t in form:
    if not is_container(t): continue
    tt = pervade(t, remove)
    if tt == Mark: return Void
    if tt == Void: continue
    subs.add(tt)

  return tuple(sorted(names)) + tuple(sorted(subs))


def solve(form, marks):
  '''
  Given a form and a set of names that are Marks assume all other names
  in the form are Void and reduce to basic value (Mark or Void.)
  '''
  for inner in form:
    if is_leaf(inner):
      if inner in marks:
        return Void
    elif solve(inner, marks) == Mark:
      return Void
  return Mark


def cycle(R, P):
  # To calculate the new R first collect all the signals in R that are
  # marks but that are not mentioned in the current P (and so cannot be
  # set to Void by it) then add the marks generated by solving P's
  # expressions with the marks in R.
  return R.difference(P).union(
    signal
    for signal, expression in P.iteritems()
    if not solve(expression, R)
    )


def reify(meaning, form):
  if is_container(form):
    return type(form)(reify(meaning, inner) for inner in form)
  return meaning.get(form, form)


def standard_form(x, form):
  Ex = reify({x: Void}, form)
  E_x_ = reify({x: Mark}, form)
  return (x, Ex), ((x,), E_x_)


def collect_names(form, names=None):
  if names is None:
    names = set()
  if is_leaf(form):
    names.add(form)
  else:
    for inner in form:
      collect_names(inner, names)
  return names


def can_unwrap(term):
  return is_container(term) and len(term) == 1 and is_container(term[0])


def unwrap(form):
  '''
  Remove all (()) and let ((*)) -> * in a form. Generator.
  '''
  for term in form:
    if term == Void:
      continue
    if can_unwrap(term): # Flatten out one "layer" of "wrapping".
      for item in term[0]:
        yield item
    else:
      yield term


_A = lambda form: (form if is_leaf(form)
                   else type(form)(unwrap(form)))


_B = lambda form: (form if is_leaf(form)
                   else
                   Void if Mark in form else form)


def Reduce(form):
  if is_leaf(form):
    return form
  if len(form) == 1 and is_container(form[0]) and len(form[0]) == 1:
    return Reduce(form[0][0])
  T = type(form)
  return T(_A(_B(T(map(Reduce, form)))))


def remy(T):
  k = len(s(T))
  while True:
    Y = Reduce(pervade(T))
    j = len(s(Y))
    if j >= k:
      return T
    T, k = Y, j


# A little visual aid to see the state of the puzzle.
def _view(r, u):
  return ''.join(
    '.O'[n in r]
    for n in u
    )



def sorter(A, B, J, K, H, L, reset):
  jq = ((A,), B)
  kq = ((B,), A)
  return {
    J: ((J, jq), reset),
    K: ((K, kq), reset),
    L: (((J,), A), (J, B)),
    H: (((K,), B), (K, A)),
    }


U = ('A', 'B', 'J', 'K', 'H', 'L', 'reset')
S = sorter(*U)

for k, v in S.items():
  print k, s(v)
print


def _bits_in(i):
  return (
    bool(i & 2**n)
    for n in (range(len(bin(i)) - 2))
    )

def z(a, b):
  for ga, gb in zip(_bits_in(a), _bits_in(b)):
    r = set()
    if ga: r.add('A')
    if gb: r.add('B')
    yield r


Z = z(20, 19)
#Z = z(19, 20)
#Z = z(23, 18)
R = next(Z)
_o = ''.join(name[0] for name in U)
print '%s    %s' % (_o, _o[2:])
for _ in range(30):
  D = cycle(R, S)
  print _view(R, U), '->', _view(D, U[2:])
##  print R
##  print D
  D = D - {"A", "B"}
##  print D
  R = next(Z) #& D
##  print R | D
##  print
  R = R | D

print _view(R, U)


##  P = {
##  ##  str(y): rule30(*map(str, (x, y, z)))
##    y: rule30(x, y, z)
##    for x, y, z in zip(
##      range(0, 80),
##      range(1, 81),
##      range(2, 82),
##      )
##    }
##
##
##  R = set()
##  for n in map(''.join, izip_longest(*map(str, sorted(P)), fillvalue='|')):
##    print n
##
##  #fr = P[40]
##
##  R.add(20)
##  R.add(60)
##  for _ in range(30):
##  ###  fr = reify(P, fr)
##  ###Y = s(fr)
##  ###print len(Y)
##    print _view(R, P)
##  #  print '40' in R
##    R = cycle(R, P)
##  print _view(R, P)
##  #print pformat(P)


##E = P[40]
##
##E = reify(P, E)
##for n in sorted(collect_names(E), reverse=True):
##  Q = standard_form(n, E)
##  X = remy(Q)
##  print 'Q', len(s(Q))
##  print 'X', len(s(X))
##  print '- ' * 10
##  E = X
##
##E = reify(P, E)
##for n in sorted(collect_names(E), reverse=True):
##  Q = standard_form(n, E)
##  X = remy(Q)
##  print 'Q', len(s(Q))
##  print 'X', len(s(X))
##  print '- ' * 10
##  E = X

##
##E = reify(P, X)
##Q = standard_form(40, E)
##X = pervade(Reduce(Q))
##print 'E', len(s(E))
##print 'Q', len(s(Q))
##print 'X', len(s(X))
##print '- ' * 10
##

##E = reify(P, X)
##Q = standard_form(40, E)
##X = pervade(Reduce(Q))
##print 'E', len(s(E))
##print 'Q', len(s(Q))
##print 'X', len(s(X))
##print '- ' * 10



##Q = standard_form(40, W)
##A = pervade(Q)
##B = Reduce(Q)
##W = Reduce(pervade(Q))
##X = pervade(Reduce(Q))
##
##print 'Q', len(s(Q))
##print 'A', len(s(A)), 'pervade(Q)'
##print 'B', len(s(B)), 'Reduce(Q)'
##print 'W', len(s(W)), 'Reduce(pervade(Q))'
##print 'X', len(s(X)), 'pervade(Reduce(Q))'


